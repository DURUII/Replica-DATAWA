\subsection{Worker Dependency Separation}
%{\color{brown}{
The primary computational challenge lies in enumerating all possible valid task combinations for each worker, leading to an exponentially expanding search space as the number of workers and tasks increases. In practice, however, a worker typically shares tasks with only a limited number of other workers who have similar or intersecting travel routes. To address this issue, we first construct a worker dependency graph and apply a graph partitioning method. We then organize the workers within each subgraph into a tree structure, ensuring that workers in sibling nodes are independent of one another. 

\subsubsection{Maximal Valid Task Sequence Generation} In this section, we first find reachable tasks, based on which the maximal valid task sequences for each worker are generated.

\textbf{Finding Reachable Tasks.}
Due to the constraints of workers' reachable distance, offline time, and tasks' expiration time, each worker $w$ can only complete a subset of tasks in their availability window $T_w$ from the current assignment time to their offline time. 
%in the given time period T. 
The reachable task subset for a worker $w$, denoted by $RS_w$, should satisfy the following constraints: $\forall s \in RS_w$,
\begin{enumerate}[i.]
    \item the task can be completed before its expiration time, i.e., $c(w.l, s.l) \le s.e-t_{now}$ (where $c(a, b)$ denotes the travel time between location $a$ and location $b$, and $t_{now}$ is the current time) and 
    \item the task can be completed within $T_w$ time interval, i.e., $c(w.l, s.l) \le T_w$ and 
    \item all the tasks in this sequence are located in the reachable range of $w$, i.e., $td(w.l, s.l) \le w.d$, where $td(a, b)$ is the travel distance between location $a$ and $b$.
\end{enumerate}

\textbf{Find Maximal Valid Task Sequence.}
Given the reachable task set $RS_w$ for worker 
$w$, we can derive the valid task sequence set $\mathbb{VR}(\mathit{RS}_w)=\{\mathit{VR}(\mathit{RS}_w)\}$ (see Definition~\ref{VR}). %with all possible orders. 
When the context is clear, we use $\mathbb{VR}$ to denote $\mathbb{VR}(RS_w)$.
We define the set of Maximal Valid Task Sequences for worker $w$ as $Q_w = \{q_1, q_2, \dots, q_{|Q_w|}\}$, where $q \in \mathbb{VR}$, and it obtains the minimal cost among all sequences in 
$\mathbb{VR}$ that consist of the same set of elements. Specifically, assuming that the order of $q$ is $(s_1, s_2, ..., s_{|q|})$, then $\forall \mathit{VR'} \in \mathbb{VR}$, the arrival time of both sequence should follow Eq.~\ref{maxvr}.
\begin{equation}
t_{q,w}(s_{|q|}) \leq  t_{\mathit{VR'},w}(s_{|\mathit{VR'}|}),
\label{maxvr}
\end{equation}
where the sequences $q$ and $\mathit{VR'}$ contain the same set of elements in different orders.

\subsubsection{Worker Dependency Graph Construction}
Given a worker set $W$ and a task set $S$, we can construct a Worker Dependency Graph (WDG), $G(W, E)$, where each node represents a worker. An edge $e(u,v) \in E$ exists between nodes $u$ and $v$ if the corresponding workers are dependent on each other. Two workers are considered dependent if they share the same reachable tasks; otherwise, they are independent. The time complexity of WDG construction is $O(|W|^2 \cdot |RS|)$, where $|RS|$ is the average number of reachable tasks for each worker.


\subsubsection{Graph Partition}
In this part, we use the maximum cardinality search (MCS) algorithm~\cite{MCS} to iteratively find maximal cliques. MCS consists of the following two steps: 

\begin{enumerate}[i.]
    \item Given a worker dependency graph (WDG), add appropriate new edges to create a corresponding chordal graph. A chordal graph is a graph in which every cycle of four or more vertices has at least one chord, where a chord is an edge that connects two non-adjacent vertices in the cycle.
    \item Find all maximal cliques in the chordal graph.
\end{enumerate}

\subsubsection{Tree Construction}
In this step, our objective is to organize the groups of workers in a tree structure so that the workers in sibling nodes are independent of each other. This setup allows us to independently solve the optimal assignment sub-problem for each sibling node. To achieve this, we use the following Recursive Tree Construction (RTC)~\cite{zhao2019destination} algorithm.

\begin{enumerate}[i.]
    \item Try to remove the cliques $X_i \in X$ (generated by the graph partition step) from the WDG, and the graph will be separated into several components. Select the cliques $X'$ that result in the highest number of components. Consider $X'$ as the parent node for each output of the recursive procedure in the next step.
    \item Apply the MCS algorithm to each sub-graph by removing workers of $X'$ and recursively applying the algorithm to the output of the MCS algorithm.
    \item Return $X'$ as the root node of this sub-tree.
\end{enumerate}

Given the worker dependency graph WDG, we construct a tree structure from the RTC algorithm, denoted by $\Gamma$(with a set of nodes $\mathbb{N}_\Gamma = \{N_1, N_2, ..., N_{|\mathbb{N}_\Gamma|}\}$), that satisfies the following properties:
\begin{enumerate}[i.]
    \item $\cup_{i \in |\mathbb{N}_\Gamma|}N_i = W$; and
    \item workers in sibling nodes are independent of each other.
\end{enumerate}


The time complexity of RTC in the $i^{th}$ recursion is $O(|X^i|+|G^i| \cdot (|V^i|+|E^i|))$, where $|X^i|$ represents the size of cliques generated by the graph partition step, $G^i$ is the subgraph set by performing step 1 in the $i^{th}$ recursion, $|E^i|$ is the number of edges in the chordal graph obtained and $|V^i|$ is the number of nodes in that chordal graph.


